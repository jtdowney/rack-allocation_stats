var allocations = <%= Yajl::Encoder.encode(allocations) %>
var pwd         = "<%= Dir.pwd %>"

$(function() {
  fillTableWith(
      _.sortBy(tupleize(_.groupBy(filterAllocationsByControls(), byFileLineAndClassPlus)), valueLength),
      ["file", "line", "class+"]
  );

  $("#gb-controls input").change(refillTable);
  $("#filter-controls input").change(refillTable);
});

function byFileLineAndClassPlus(allocation) {
  return JSON.stringify([allocation["file"], allocation["line"], allocation["class_plus"]]);
}

function fillTableWith(groups, headers) {
  /* table headers */
  var headTr = $("<tr/>");
  var fileColonLineIndex = null;
  var lineIndex = null;
  var classPathSpaceMethodIdIndex = null;
  var methodIdIndex = null;
  for (i in headers) {
    /* i is not an integer; the first i plus 1 is "01" */
    if (headers[i] === "file" && headers[i*1 + 1] === "line") {
      fileColonLineIndex = i;
      headers[i] = "file:line";
    }

    if (fileColonLineIndex && headers[i] === "line") {
      lineIndex = i;
      continue;
    }

    /* i is not an integer; the first i plus 1 is "01" */
    if (headers[i] === "class_path" && headers[i*1 + 1] === "method_id") {
      classPathSpaceMethodIdIndex = i;
      headers[i] = "class_path:method_id";
    }

    if (classPathSpaceMethodIdIndex && headers[i] === "method_id") {
      methodIdIndex = i;
      continue;
    }

    headTr.append("<th>" + headers[i] + "</th>");
  }
  headTr.append("<th>count</th>");
  $("#allocations thead").html(headTr);
  $("#allocations tbody").empty();
  var totalCount = 0;

  for (var tuple in groups) {
    var key    = groups[tuple][0];
    var allocs = groups[tuple][1];
    var tr = $("<tr/>");
    keys = eval(key); /* unstringify */
    for (var i in keys) {
      if (fileColonLineIndex          && i === lineIndex)     { continue; }
      if (classPathSpaceMethodIdIndex && i === methodIdIndex) { continue; }

      if (i === fileColonLineIndex) {
        tr.append($("<td>").text(keys[i] + ":" + keys[lineIndex]));
      } else if (i === classPathSpaceMethodIdIndex) {
        tr.append($("<td>").text(keys[i] + " " + keys[methodIdIndex]));
      } else {
        tr.append($("<td>").text(keys[i]));
      }
    }

    count = allocs.length;
    totalCount += count;
    tr.append($("<td>").addClass("align-right").text(count));

    $("#allocations tbody").append(tr);
  }

  var footerTr = $("<tr/>");
  footerTr.
      addClass("footer").
      append('<td class="align-right" colspan="' + headers.length + '">total count</td>').
      append('<td class="align-right">' + totalCount + "</td>").
      appendTo($("#allocations tbody"));

  $("#allocations-row-count").text(groups.length + " rows");
}

function groupByFields(list, fields) {
  return _.groupBy(list, function(allocation) {
    values = new Array();

    for (i in fields) {
      values.push(allocation[fields[i]]);
    }
    return JSON.stringify(values);
  });
}

function filterOutPwd(filtered) {
 return $.grep(filtered, function(a) {
   var r = new RegExp(pwd);
   return r.exec(a["file"]) === null;
 });
}

function filterOutRuby(filtered) {
 return $.grep(filtered, function(a) {
   var r = new RegExp("<RUBYLIBDIR>");
   return r.exec(a["file"]) === null;
 });
}

function filterOutEval(filtered) {
 return $.grep(filtered, function(a) {
   return a["file"] !== "(eval)";
 });
}

function filterAllocationsByControls() {
  var filtered = allocations;
  if ($("#filter-pwd")[0].checked) {
    filtered = filterOutPwd(filtered);
  }
  if ($("#filter-ruby")[0].checked) {
    filtered = filterOutRuby(filtered);
  }
  if ($("#filter-eval")[0].checked) {
    filtered = filterOutEval(filtered);
  }

  return filtered;
}

function refillTable(e) {
  // Filter stuff
  filtered = filterAllocationsByControls();

  // Group stuff by other stuff
  var gbInputs = $("#gb-controls").find("input");
  fields = new Array();

  $.each(gbInputs, function(idx, gbInput) {
    if (gbInput.checked) {
      fields.push(gbInput.getAttribute("name"));
    }
  });

  fillTableWith(_.sortBy(tupleize(groupByFields(filtered, fields)), valueLength), fields);
}

function tupleize(object) {
  tuples = [];
  for (var key in object) {
    tuples.push([key, object[key]]);
  }

  return tuples;
}

function valueLength(tuple) {
  return - tuple[1].length; /* descending */
}
